load system io.


structure Integral with

  data a. -- lower bound
  data b. -- upper bound
  data f. -- integrand
  data p. -- number of parts it's split up into (# of rectangles)
  data Dx. -- delta

  function __init__
    with (a:%real, b:%real, f:%function) do
      let this@a = a.
      let this@b = b.
      let this@f = f.
    with (a:%real, b:%real, f:%function, p:%integer) do
      let this@a = a.
      let this@b = b.
      let this@f = f.
      let this@p = p.
      this@calc_Dx(p).
    with (a:%real, b:%real, f:%function, p:%integer, Dx) do
      let this@a = a.
      let this@b = b.
      let this@f = f.
      let this@p = p.
      let this@Dx = Dx.
    with _ do
      throw Error "invalid arguments for Integral constructor"
  end

  function calc_Dx
    with p:%integer do
      let this@Dx = (this@b - this@a) / toreal(p).
    with _ do
      throw Error "invalid arguments for calculate delta method"
  end

  function dec_b -- fix to use multi-dispatching somehow so i dont have to generate a new structure every time i want to decrement a freaking value!
    with none do
       Integral(this@a, this@b-this@Dx, this@f, this@p-1, this@Dx)
    with _ do
      throw Error "expected no arguments"
  end
end

-- NOTE: odd values of d may be funky for mid. Is this concerning? Requires investegation, probably

-- need to add comment here
function right with (I:%Integral) do
  function right_rec with (I:%Integral, t) do
    I @Dx * (t + I @f(I @b)) if I @a + I @Dx == I @b
    else right_rec (I @dec_b(), t + I @f(I @b))
  end
  right_rec(I, 0.0)
end



-- test code
let my_integral = Integral(0.0, 6.0, lambda with n do n*n*n + n, 3).
io @println (my_integral).
--io @println (my_integral @dec_b()).
io @println (right(my_integral))