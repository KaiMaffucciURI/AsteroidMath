load system io.
--load system math.

-- simple test function(s)
-- but you can toss any lambda as your function into any of the other function applications
function f with x do x*x*x - 4.0*x*x - 3.0*x - 1.0 end

-- NOTE: odd values of d may be funky for mid. Is this concerning? Requires investegation, probably

-- TODO: rewrite to be able to run in functional mode (-F flag)
-- TODO: force all parameters to be reals
-- TODO: find delta function
-- TODO: make integral pattern thingy so you can put in an integral instead of having one parameter for each thing
-- TODO: make base function & recursive versions, aka using practices from 212

-- a & b are lower & upper limits, d is change (upper limit / parts), f is function, t is total
function right with (a, b, d, f, t) do
  if a+d == b do d * (t + f(b))
  else do right (a, b-d, d, f, t + f(b))
  end
end

function left with (a, b, d, f, t) do
  if a == b-d do d * (t + f(b-d))
  else do left (a, b-d, d, f, t + f(b-d))
  end
end

function mid with (a, b, d, f, t) do
  if gettype(t) == "none" do mid (a + d/2.0, b - d/2.0, d, f, 0.0)
  elif a == b do d*(t + f(b))
  else do mid (a, b-d, d, f, t + f(b))
  end
end

-- trap[ezoid]
function trap with (a, b, d, f) do
  (right(a, b, d, f, 0.0) + left(a, b, d, f, 0.0)) / 2.0
end

-- simp[son's]
function simp with (a, b, d, f) do
  (2.0*mid(a, b, d*2.0, f, ()) + trap(a, b, d*2.0, f)) / 3.0
end

-- test code
io @println(trap(0.0, 8.0, 2.0, f)).
io @println(simp(0.0, 8.0, 2.0, f)).